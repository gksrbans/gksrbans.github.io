---
toc: true
toc_label: "Dynamic-Programming(DP)"
toc_icon: "cog"
---

# Dynamic Programming, DP
> Update : 2020-11-16  

# Dynamic Programming ??
다이나믹 프로그래밍이란 특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 [알고리즘](https://namu.wiki/w/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 "알고리즘") 이라고 합니다.  

반복적으로 계산되는 것들의 계산 횟수를 줄이기 위해 이전에 계산했던 값을 저장해두었다가 나중에 재사용하는 방법이라고 생각하면 편할것 같다.  
> 썼던 것 재사용하는 알고리즘(?)  

분할 정복 기법이란 큰 문제를 한 번에 해결하기 힘들 때 작은 여러 개의 문제로 나누어서 푸는 기법인데 작은 문제를 해결하다 보면, 반복되서 푸는 문제가 있기마련. 이러한 문제를 해결하기 위해 풀었던 문제에 대한 해답을 미리 저장해놓는 알고리즘이 바로 동적 알고리즘이라고 할 수 있겠다.  

# 구현
앞서 말했듯이 구현의 경우 분할정복 기법과 거의 비슷하다고 할 수 있다.  
DP 역시 전체 문제를 부분문제로 나누어서 각 부분 문제의 답을 계산하고, 이 계산한 결과값을 이용해 원래의 최적해를 구함.  
(반복된 계산은 하지 않는게 분할정복과의 차이점)  

## 1. 접근
동적 계획법의 구현에 가장 많이 사용되는 예는 피보나치 수열이다.  
-   f(a,b) = f(a-1,b) + f(a,b-1) (a,b >= 1 )  
    
-   f(0,0) = 1, 임의의 자연수 n에 대해 f(n,0) = f(0,n) = 1  
위와 같은 피보나치 함수에서 f(2,2)를 구하는 방법은 다음과 같다.  
![](https://gksrbans.github.io/assets/images/Fibonacci.png)  

f(2,2)를 구하기 위해서 총 5번의 연산을 거쳐야 하며, 이때 중복되는 부분문제는 f(1,1) 하나 뿐이므로 속도에 큰 이득을 볼 수 없지만 a,b값이 커질 수록 기하급수적으로 속도면에서 이득을 볼 수 있음.  

## 2. 재귀함수 형태의 피보나치 수열
- 일반적인 Recursive Form 피보나치 수열
```python
def 귬보나치(num):  
    if num <= 1:  
        return num  
    else  
 return 귬보나치(num-2) + 귬보나치(num-1)  
      
# 이딴식으로 recursive 재귀함수 쓰면 시.공간 복잡도 터져서 프로그램 디져버림
```
## 3. DP를 활용한 피보나치 수열
```python
def 재귀귬보나치(num):  
    val = [0, 1]  
    if num <=1:  
        return val[num]  
    else:  
        for i in range(2,num+1):  
            val.append(val[i-1] + val[i-2])  
        return val[num]  
  
# 요로케 하면 반복적인 연산을 하지 않고 val 배열 내 겹치는 index가 없음
```
## 4. 슬라이딩 윈도우 기법
```python
def 슬라이딩귬보나치(num):  
    if num <=1:  
        return num  
    v0, v1 = 0, 1  
  for _ in range(num):  
        v0, v1 = v1, v1+v0  
    return v1  
  
# 요로케 짜면 공간복잡도 역시 공간재사용 하지않고 피보나치수열 간단하게 가능  
```
# 메모이제이션(Memoization)
  메모리제이션(memorization)아님 메모이제이션임(memoization)  
하위 문제를 해결할 때 그 해결책을 저장해 두었다가, 똑같은 문제가 발생했을 때 저장되어 있던 해결책 값을 가져와서 해결함.  
=> 이렇게 동일한 문제를 반복해야 할 경우, 한 번 계산된 값을 활용해 중복 계산을 줄이는 것을 메모이제이션이라고 함.  

동적 계획법은 모든 방법을 일일이 검토해서 최적의 해를 찾아냄.  
그리디 알고리즘은 순간순간마다 최적의 해를 찾지만, 그 해가 항상 최적의 해라는 보장은 할 수 없음.  하지만 DP는 모든 방법을 고려해 시간이 오래걸릴 수 있으나 항상 최적의 해를 구함.


